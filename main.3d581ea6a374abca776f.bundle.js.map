{"version":3,"file":"main.3d581ea6a374abca776f.bundle.js","sources":["webpack:///./index.coffee"],"sourcesContent":["# A dictionary for storing data per-element\ncounter = 0\ninstances = {}\n\n# Support toggling of global disabled state\ndisabled = false\nexport disable = -> disabled = true\nexport enable = -> \n\tdisabled = false\n\tupdate instance for id, instance of instances\n\n# Create instance after the element has been added to DOM\nstartObserving = (el, binding) ->\n\t\n\t# If an indvidual instance is disabled, just add the in viewport classes\n\t# to reveal the element\n\tif binding?.value?.disabled || directive.defaults.disabled || disabled\n\t\tel.classList.add.apply el.classList, [ 'in-viewport' ]\n\t\treturn\n\n\t# Create the instance object \n\tinstance = observer: makeObserver el, binding\n\t\n\t# Generate a unique id that will be store in a data value on the element\n\tid = 'i' + counter++\n\tel.setAttribute 'data-in-viewport', id\n\tinstances[id] = instance\n\n# Make the instance\nmakeObserver = (el, { value = {}, modifiers }) ->\n\t\n\t# Make the default root\n\troot = value.root || directive.defaults.root\n\troot = switch typeof root\n\t\twhen 'function' then root()\n\t\twhen 'string' then document.querySelector root\n\t\twhen 'object' then root # Expects to be a DOMElement\n\t\n\t# Make the default margin\n\tmargin = if typeof value == 'string' then value\n\telse value.margin || directive.defaults.margin\n\t\n\t# Make the observer callback\n\tcallback = ([entry]) -> update { el, entry, modifiers }\n\t\t\n\t# Make the observer instance\n\tobserver = new IntersectionObserver callback,\n\t\troot: root\n\t\trootMargin: margin\n\t\tthreshold: [0,1]\n\t\t\n\t# Start observing the element and return the observer\n\tobserver.observe el\n\treturn observer\n\n# Update element classes based on current intersection state\nupdate = ({ el, entry, modifiers }) ->\n\t\n\t# Destructure the entry to just what's needed\n\t{ boundingClientRect: target, rootBounds: root } = entry\n\n\t# Init vars\n\tadd = [] # Classes to add\n\tremove = [] # Classes to remove\n\n\t# Util to DRY up population of add and remove arrays\n\ttoggle = (bool, klass) -> if bool then add.push klass else remove.push klass\n\n\t# Determine viewport status, see vue-in-viewport-mixin for more info:\n\t# https://github.com/BKWLD/vue-in-viewport-mixin/blob/master/index.coffee\n\tinViewport = target.top <= root.bottom and target.bottom > root.top\n\tabove = target.top < root.top\n\tbelow = target.bottom > root.bottom + 1\n\n\t# Determine which classes to add\n\ttoggle inViewport, 'in-viewport'\n\ttoggle above, 'above-viewport'\n\ttoggle below, 'below-viewport'\n\n\t# Apply classes to element\n\tel.classList.add.apply el.classList, add if add.length\n\tel.classList.remove.apply el.classList, remove if remove.length\n\n\t# If set to update \"once\", remove listeners if in viewport\n\tremoveObserver el if modifiers.once and inViewport\n\n# Compare two objects.  Doing JSON.stringify to conpare as a quick way to\n# deep compare objects\nobjIsSame = (obj1, obj2) -> JSON.stringify(obj1) == JSON.stringify(obj2)\n\n# Remove scrollMonitor listeners\nremoveObserver = (el) ->\n\tid = el.getAttribute 'data-in-viewport'\n\tif instance = instances[id]\n\t\tinstance.observer?.disconnect()\n\t\tdelete instances[id]\n\n# Mixin definition\nexport default directive =\n\n\t# Define overrideable defaults\n\tdefaults:\n\t\troot: undefined\n\t\tmargin: '0px 0px -1px 0px'\n\t\tdisabled: false\n\n\t# Init\n\tinserted: (el, binding) -> startObserving el, binding\n\n\t# If the value changed, re-init observer\n\tcomponentUpdated: (el, binding) ->\n\t\treturn if objIsSame binding.value, binding.oldValue\n\t\tremoveObserver el\n\t\tstartObserving el, binding\n\n\t# Cleanup\n\tunbind: (el) -> removeObserver el\n"],"mappings":"AAAA","sourceRoot":""}